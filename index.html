<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Union Dental Scanner</title>
  <style>
    html,body { margin:0; height:100%; background:#000; color:#fff; font-family:system-ui; }
    .wrap { display:flex; flex-direction:column; height:100%; }
    video { width:100%; height:100%; object-fit:cover; }
    .toolbar { position:fixed; bottom:0; left:0; right:0; display:flex; gap:8px; padding:12px; background:rgba(0,0,0,.6); backdrop-filter:blur(6px); }
    button { flex:1; padding:14px 16px; border-radius:12px; border:0; font-size:16px; }
    .pill { position:fixed; top:12px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.6); padding:8px 12px; border-radius:999px; font-weight:600; }
  </style>
  <!-- ZXing JS (browser bundle) -->
  <script src="https://unpkg.com/@zxing/browser@latest"></script>
</head>
<body>
  <div class="wrap">
    <video id="preview" playsinline muted></video>
    <div id="status" class="pill">ready</div>
    <div class="toolbar">
      <button id="start">Start</button>
      <button id="torch">Torch</button>
      <button id="undo">Undo</button>
    </div>
  </div>
<script>
  const ENDPOINT = 'https://script.google.com/macros/s/AKfycbwaR92rGXO3vOnDNdnMnWmelNmB5SWlJ-V7X8ZUI-yb-Pdby-bEHLYF45tu77A1H05xeQ/exec';

  const video    = document.getElementById('preview');
  const statusEl = document.getElementById('status');
  const startBtn = document.getElementById('start');
  const torchBtn = document.getElementById('torch');
  const undoBtn  = document.getElementById('undo');

  let stream = null;
  let codeReader = null;
  let controls = null;
  let currentDeviceId = null;
  let lastScan = { text: null, ts: 0 };
  let lastSent = null;

  function setStatus(t) { statusEl.textContent = t; console.log('[status]', t); }

  function uuid() {
    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
  }

  async function ensureCameraPermission() {
    if (!navigator.mediaDevices?.getUserMedia) {
      throw new Error('getUserMedia not supported. Use a modern browser (HTTPS required).');
    }
    try {
      // Try environment first; iOS Safari honors facingMode better on a user gesture.
      return await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: 'environment' } },
        audio: false
      });
    } catch (e) {
      // As a fallback, allow any camera.
      setStatus('Retrying with default camera…');
      return await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    }
  }

  async function attachStream(s) {
    stream = s;
    video.srcObject = stream;
    // iOS requires play() after a user gesture
    await video.play();
    setStatus('Camera ready. Point at a barcode…');
  }

  async function pickBackCamera() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const vids = devices.filter(d => d.kind === 'videoinput');
    if (!vids.length) throw new Error('No camera devices found.');
    const back = vids.find(d => /back|rear|environment/i.test(d.label));
    return (back || vids[0]).deviceId;
  }

  async function startZXing() {
    if (!window.ZXingBrowser) {
      setStatus('ZXing not loaded; scanning disabled.');
      return;
    }
    codeReader = new ZXingBrowser.BrowserMultiFormatReader();

    // Prefer the specific deviceId if we can get it (post-permission labels are available)
    try {
      currentDeviceId = await pickBackCamera();
    } catch (e) {
      console.warn('pickBackCamera failed:', e);
    }

    // If we already have a live <video>, ZXing can read directly from it.
    try {
      controls = await codeReader.decodeFromVideoElement(video, (result, err) => {
        if (result) handleResult(result.getText());
      });
      setStatus('Scanner active. Scan a code…');
    } catch (e) {
      // Fallback to device-based decoding
      setStatus('Switching to device-based scanner…');
      controls = await codeReader.decodeFromVideoDevice(currentDeviceId || null, video, (result, err) => {
        if (result) handleResult(result.getText());
      });
      setStatus('Scanner active. Scan a code…');
    }
  }

  async function startCamera() {
    try {
      setStatus('Requesting camera…');
      // 1) Ask for camera and attach stream
      const s = await ensureCameraPermission();
      await attachStream(s);

      // 2) Start the decoder after stream is playing
      await startZXing();
    } catch (err) {
      console.error(err);
      let msg = String(err && err.message || err);
      if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        msg += ' | Tip: Must be served over HTTPS (or localhost) for camera access.';
      }
      setStatus('Error: ' + msg);
      alert('Camera error:\n' + msg);
    }
  }

  async function handleResult(text) {
    const now = Date.now();
    if (text === lastScan.text && (now - lastScan.ts) < 1500) return; // debounce
    lastScan = { text, ts: now };
    setStatus(`scanned: ${text}`);
    try { navigator.vibrate?.(60); } catch {}

    // Send to your endpoint
    const payload = { scan_id: uuid(), barcode: text, delta: -1, device: currentDeviceId || 'unknown' };
    lastSent = payload;

    try {
      const resp = await fetch(ENDPOINT, {
        method: 'POST',
        body: JSON.stringify(payload)  // text/plain by default
      });
      const data = await resp.json().catch(() => ({}));
      if (!resp.ok || !data.ok) {
        setStatus(`write error: ${data.error || resp.status}`);
      } else if (data.duplicate) {
        setStatus('duplicate (ignored)');
      } else {
        setStatus(`ok. stock: ${data.stock_after}`);
      }
    } catch (e) {
      setStatus('network error (saved locally?)');
      console.error(e);
    }
  }

  async function toggleTorch() {
    const track = video.srcObject?.getVideoTracks?.()[0];
    if (!track) return setStatus('no video track');
    const caps = track.getCapabilities?.() || {};
    if (!('torch' in caps)) return setStatus('torch not supported on this device');
    const on = !!track.getSettings().torch;
    await track.applyConstraints({ advanced: [{ torch: !on }] });
    setStatus(!on ? 'torch on' : 'torch off');
  }

  async function undoLast() {
    if (!lastSent) return setStatus('nothing to undo');
    const payload = { ...lastSent, scan_id: uuid(), delta: +1 };
    const resp = await fetch(ENDPOINT, {
      method: 'POST',
      body: JSON.stringify(payload)  // text/plain by default
    });
    const data = await resp.json().catch(() => ({}));
    setStatus(data.ok ? `undo ok. stock: ${data.stock_after}` : `undo failed`);
  }

  startBtn.onclick = startCamera;   // user gesture → camera permission works on iOS
  torchBtn.onclick = toggleTorch;
  undoBtn.onclick  = undoLast;
</script>
</body>
</html>
